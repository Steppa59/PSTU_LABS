#include <iostream>
using namespace std;
int a;
int F =-1;          // Переменная для нахождения первого четного числа
struct Stack {
int data;                   //данные
Stack* prev;                 //адрес
};

Stack* make_stack(int n)      {//создание стека
if (n == 0) return NULL;
Stack* top, * p;            // top - указатель на верхний элемент стека
top = NULL;                 // Пока он ни на что не указывает
p = new Stack;              // Выделение памяти под 1 элемент
cin >> a;
p->data = a;
p->prev = NULL;             // Так как он первый, то снизу элементов нет
top = p;                    // Показываем, что введённый элемент стал первым 
for (int i = 2; i <= n; i++) {
Stack* h = new Stack;   // Выделение памяти для нового элемента
cin >> a;
h->data = a;
h->prev = top;          // Указываем на нижний элемент 
top = h;                // Показываем, что введённый элемент стал первым 
}
return top;
    
}

void print_stack(Stack* top) { //печать стека
if (top == NULL) {
cout << "стек пуст" << endl;
}
else {
Stack* p = top;        // p указывает на первый элемент
while (p != NULL)   {   // Пока существуют элементы 

if (((p->data % 2) == 0)&&(F==-1)) { // Проверяем каждый элемент до тех пор пока не найдем первый четный
F = p->data;                         // Запоминаем значение самого первого четного числа
}                                    // Конец проверки

cout << p->data << " ";// Вывод ключа
p = p->prev;       // Переход к следующему элементу
}
cout << endl;
}
}

int pop(Stack*& top) { // Возвр-ие первого элемента и его удаление
Stack* p = top;           // p указывает на первый элемент
int k = 0;                // Кол-во элементов в стеке
while (p != NULL)   {      // Считаем кол-во элементов
k++;
p = p->prev;
}
p = top;
if (k == 1) { // Если элемент один, то обнуляем указатели и возвращаем последний элемент 
int t = top->data;
delete p;
top = NULL;
return t;
}
else { // если больше 1
Stack* t = p->prev;       // Указатель на второй элемент
int u = p->data;         // Сохранение значения последнего элемента 
top = t;                  // И он теперь первый элемент
delete p;                 // Удаление последнего элемента
return u;                 // Возвращение первого элемента
}
}

Stack* push(Stack*& top, int val) { // Функция добавления элемента в стек
Stack* p = new Stack;        // Выделение памяти для нового элемента
p->data = val;               // Присваивание нового элемента
p->prev = top;               // Новый элемент указывает на нижний элемент 
top = p;                     // Новый элемент стаёт первым элементом стека 
return top;
}

int main() {
cout << "Введите количество элементов: ";
int n;
cin >> n;
cout << "Введите элементы стека: ";
Stack* st = make_stack(n);    // Создание стека
cout << "Стек: ";
print_stack(st);              // Печать стека





int k;
k = 0;
Stack* st2 = make_stack(0);   // Создание стека (пустого)
for (int i = 0; i < n; i++) { //перенос всех элементов кроме эл. с ключом F во 2 стек
int t = pop(st);
if (t!=F) {
push(st2, t);
}
else {
k = k + 1;
}
}
n = n - k;
for (int i = 0; i < n; i++) { //перенос всех элементов в начальный стек
int t = pop(st2);
push(st, t);
}
cout << "Стек после удаления первого четного числа: ";
print_stack(st);
    return 0;
}
